# -*- coding: utf-8 -*-
"""FordSmartCar.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L8eSq_J9jw9Q4JBSmZnSwg3YoN8v0GZ1
"""

#Get refresh token
import requests

url = "https://dah2vb2cprod.b2clogin.com/914d88b1-3523-4bf6-9be4-1b96b4f6f919/oauth2/v2.0/token?p=B2C_1A_signup_signin_common"

payload={'grant_type': 'refresh_token',
'refresh_token': 'eyJraWQiOiI2cjIzQ2FTeTF4cFdUUFBxYVRtX01Vc2RKZGo1RWlDTnRtME4yVTAxNTdFIiwidmVyIjoiMS4wIiwiemlwIjoiRGVmbGF0ZSIsInNlciI6IjEuMCJ9.fhWAdOxS0znEsy8_HTmB5J2qGraOU17OVT9RU7PsFcUmCOIv_TBLBqhaFLgY2WUCz8IwoPiOxxaB5RnCL-uz7w96tpDonUrJKVboGIvl0iLE9lLv8sbmzSr0AovG_Rv2LXd8TRzImr27JBWVWpTV28rOxViTz62nV65SOEOXNwSI_jZWyZRPqoM3Ichn-dc2qzXvt8STDOTuA67jjZh3Vlg6qpxxuHdpvR97k7q_ywwsE6vDXq6exXuSzhWcPuO0VbT5L_J7hqOtGpEZ2nc68VSijf7zTLzOUCuNcXrPD4faz6YX2wcJk_KPiQQFTreSTX6MPXwiBEhxm-lvWLL15A.3_BIKzBs1cPgJ6x3.Ypd4JiU4m0KWSDvZ7W1b9BL_hMUcNdDXXG-QxgqGj4nzggOfcZE16KIXbUxqRQI2y7oBGUYguHoUf6x3sBlHJ3R1cNWwrj-tNHjIepT2XDIYvDkgisjNtZzS-ux-oDzlyASEY_dfgtQQ0fa-nrL_vYKce3FQGFGdlteJ1LZ3TE7GXkoypm_uX7okqNzM73hKwnF3p8OWTHhRIIcWc_ChHAJ6URZrPdjfhafYzkYsm3tsGgeMNSDw7irrKQKdRJ7jaJQELorISw5izyDIuLDFTf8A0VdJbBPkOXmLAc11iCcijFUBq7iJNP-PuY-uWXdAuRw4FyhZZmg8nQy6aI_wnrNe-MeqfbqKcIrcRa8vuh7aUm3tYy2yQFGndV6lTdS6q1g6FifkJ6mD_zQH-e9istvhbQdQol5wV0tgutT0MhWBdeX8htyfedh2Ou8XPA-Prdc41ckrN2DMT16TP_dRwklnIsxLpUmO7fXJm0sPzFjBjRawYDV1LYIS1--HrGH8Y87UIBLtUqGyqCP1exXWOEz36mGhOj24jf3W5g6-gBXUXJybc_MD6pO-79DgL8ylY4cAQHMMIWL6DSX2GVP_AEl2br2nUXXSpY2HHCNkYkCWP8Q3Ji_NngKJ0V6ALNmpXIaGo7_s2mIfQA4BEyaZzkzhqVO5CKM_ZfKBc3s9skjextD_RAJr2LOvQefPlCG1WRwUfRKuVVIS6ECW2eZ19aYFbEOHf4C2-_nhU5D3g0SDnkO-98RA1VQ8WJopTU9U4qRhfRdw0XuKxFKwtu498O1muMNRysCnYEBHEyPYBaPTOGOMbrtkgLl5mvzjPDQ_oDWQ7S-s5Iu7-TfnAiWNehsFDA.PXg7Ije0AF17mn859r_90A',
'client_id': '30990062-9618-40e1-a27b-7c6bcb23658a',
'client_secret': 'T_Wk41dx2U9v22R5sQD4Z_E1u-l2B-jXHE'}
files=[

]
headers = {}

response = requests.request("POST", url, headers=headers, data=payload, files=files)

print(response.text)
json_result = response.json()
daniel_access_token = json_result['access_token']

#Get long and lattitude
def getLocation():
  import requests

  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/location"

  #daniel_access_token="eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6IlMxUEZhdzdkR2s3bHNFQmEzUjVWMnRLSzVYYnNIWEJsemFXZGhjNUVNdW8ifQ.eyJpc3MiOiJodHRwczovL2RhaDJ2YjJjcHJvZC5iMmNsb2dpbi5jb20vOTE0ZDg4YjEtMzUyMy00YmY2LTliZTQtMWI5NmI0ZjZmOTE5L3YyLjAvIiwiZXhwIjoxNjI0MjQ2NzY3LCJuYmYiOjE2MjQyNDU1NjcsImF1ZCI6ImMxZTRjMWEwLTI4NzgtNGU2Zi1hMzA4LTgzNmIzNDQ3NGVhOSIsImxvY2FsZSI6ImVuIiwiaWRwIjoiYjJjX0RwSzFPQW44ZFEiLCJtdG1JZCI6IjUxMzMzYWEzLWIyOWQtNGQ2Yy1hZDM2LTBiNjg2MWU2MjA4OSIsInVzZXJHdWlkIjoiSTVaSlAxNmdWREpQWmVCeVhmRVR5cVBJaklZbWQ0WDlKV2Q2UWQremsyT3VZTkxiUjJYYnFzRThTWUIvQm96TiIsInN1YiI6IjgxOTVmZTYwLWM4NTktNDRhMy1hMzc1LWVjZGMzMDE3OTFhNiIsIm5vbmNlIjoiMTIzNDU2Iiwic2NwIjoiYWNjZXNzIiwiYXpwIjoiMzA5OTAwNjItOTYxOC00MGUxLWEyN2ItN2M2YmNiMjM2NThhIiwidmVyIjoiMS4wIiwiaWF0IjoxNjI0MjQ1NTY3fQ.P3ovUHR5nJaGSuoT--s4iZvv5_Y6pwZCjlHF9117fFyb76suLv5s3kqgsI-Pfi2Go-tWagkMGS-C1mv6QId-FG_R7RQaDzMtNrOvQHLCucKiy1bjo6PmpGHPzgotf1G3CQ_YxXvKcku5wf2GQJZYWAUWY-pFMQC4U-J_uouETF1IZa2UaGq6dMbgxYGy3A9ukEwnPCPMbJ5izz6DPiVmpa8aes3I6_A6GLWbfOSs4t1-bYAHA56l3SVqxsPS9U_yg_DIumEjaZkVshmz-C7UDzf43CIuaJ7114nC-ppANzvPa3fOjXhsN5HNgw6PIfWgLRqRtOzgLvq-5H0wQSyPYQ" 
  payload={}
  headers = {
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01'
  }

  response = requests.request("GET", url, headers=headers, data=payload)

  print(response.text)
  json_result = response.json()
  print(json_result['vehicleLocation']['longitude'], json_result['vehicleLocation']['latitude'])
  return url, json_result

#get vehicle information
def getVehicleInfo():
  import requests

  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a"

  payload={}
  headers = {
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01'
  }

  response = requests.request("GET", url, headers=headers, data=payload)

  print(response.text)
  json_result = response.json()
  print(f"Odometer={json_result['vehicle']['vehicleDetails']['odometer']}")
  return url,json_result

def getVehicleStatus():
  # Vechicle status POST/GET
  import requests
  import json

  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/status"

  payload={}
  files={}
  headers = {
    'Accept': '*/*',
    'Content-Type': 'application/json',
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01',
    'callback-url': '{{callback-url}}'
  }

  response = requests.request("POST", url, headers=headers, data=payload, files=files)

  print(response.text)
  command_id = response.json()['commandId']
  print(command_id)

  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/statusrefresh/" + command_id

  payload={}
  files={}
  headers = {
    'Accept': '*/*',
    'Content-Type': 'application/json',
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01',
    'callback-url': '{{callback-url}}'
  }

  response = requests.request("GET", url, headers=headers, data=payload, files=files)
  json_result = response.json()
  print(json_result)
  print(f"Lock status ={json_result['vehiclestatus']['lockStatus']} Alarm={json_result['vehiclestatus']['alarm']}")
  return url, json_result
getVehicleStatus()

def startCharging():
  import requests
  import json

  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/startCharge"

  payload={}
  files={}
  headers = {
    'Accept': '*/*',
    'Content-Type': 'application/json',
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01',
    'callback-url': '{{callback-url}}'
  }

  response = requests.request("POST", url, headers=headers, data=payload, files=files)
  json_result = response.json()
  print(response.text)
  return url, json_result

def stopCharging():
  import requests
  import json

  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/stopCharge"

  payload={}
  files={}
  headers = {
    'Accept': '*/*',
    'Content-Type': 'application/json',
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01',
    'callback-url': '{{callback-url}}'
  }

  response = requests.request("POST", url, headers=headers, data=payload, files=files)
  json_result = response.json()
  print(response.text)
  return url, json_result
# Vehicle start engine POST and GET status engine
def startEngine():
  import requests

  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/startEngine"

  payload={}
  headers = {
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01'
  }

  response = requests.request("POST", url, headers=headers, data=payload)
  json_result = response.json()
  print(response.text)
  command_id = json_result['commandId']
  return url, json_result
  
  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/startEngine/" + command_id

  payload={}
  headers = {
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01'
  }

  response = requests.request("GET", url, headers=headers, data=payload)

  print(response.text)

# Vehicle stop engine POST and GET status engine
def stopEngine():
  import requests

  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/stopEngine"

  payload={}
  headers = {
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01'
  }

  response = requests.request("POST", url, headers=headers, data=payload)
  json_result = response.json()
  print(response.text)
  command_id = json_result['commandId']
  return url, json_result
  
  url = "https://api.mps.ford.com/api/fordconnect/vehicles/v1/8a7f9fa878849d8a0179579d2f26043a/stopEngine/" + command_id

  payload={}
  headers = {
    'Application-Id': 'afdc085b-377a-4351-b23e-5e1d35fb3700',
    'Authorization': f'Bearer {daniel_access_token}',
    'api-version': '2020-06-01'
  }

  response = requests.request("GET", url, headers=headers, data=payload)

  print(response.text)

"""
from google.colab import drive

drive.mount('/content/gdrive')

!ls /content/gdrive/MyDrive/Ford/templates

!pip install flask
!pip install flask-ngrok
!pip install APScheduler
"""

"""# To Get Grok Address - making functions"""

#import atexit
import json
import os
import platform
import shutil
import subprocess
import tempfile
import time
import zipfile
import math
from pathlib import Path
from threading import Timer
import datetime
import requests
ngrok_address = None

def _run_ngrok():
    ngrok_path = str(Path(tempfile.gettempdir(), "ngrok"))
    _download_ngrok(ngrok_path)
    system = platform.system()
    if system == "Darwin":
        command = "ngrok"
    elif system == "Windows":
        command = "ngrok.exe"
    elif system == "Linux":
        command = "ngrok"
    else:
        raise Exception(f"{system} is not supported")
    executable = str(Path(ngrok_path, command))
    os.chmod(executable, 777)

    ngrok = subprocess.Popen([executable, 'http', '5000'])
    atexit.register(ngrok.terminate)
    localhost_url = "http://localhost:4040/api/tunnels"  # Url with tunnel details
    time.sleep(1)
    tunnel_url = requests.get(localhost_url).text  # Get the tunnel information
    j = json.loads(tunnel_url)

    tunnel_url = j['tunnels'][0]['public_url']  # Do the parsing of the get
    tunnel_url = tunnel_url.replace("https", "http")
    return tunnel_url


def _download_ngrok(ngrok_path):
    if Path(ngrok_path).exists():
        return
    system = platform.system()
    if system == "Darwin":
        url = "https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-darwin-amd64.zip"
    elif system == "Windows":
        url = "https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-windows-amd64.zip"
    elif system == "Linux":
        url = "https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip"
    else:
        raise Exception(f"{system} is not supported")
    download_path = _download_file(url)
    with zipfile.ZipFile(download_path, "r") as zip_ref:
        zip_ref.extractall(ngrok_path)


def _download_file(url):
    local_filename = url.split('/')[-1]
    r = requests.get(url, stream=True)
    download_path = str(Path(tempfile.gettempdir(), local_filename))
    with open(download_path, 'wb') as f:
        shutil.copyfileobj(r.raw, f)
    return download_path

def start_ngrok():
    global ngrok_address
    ngrok_address = _run_ngrok()
    print(f" * Daniel Running on {ngrok_address}")
    print(f" * Traffic stats available on http://127.0.0.1:4040")
    


def daniel_run_with_ngrok(app):
    """
    The provided Flask app will be securely exposed to the public internet via ngrok when run,
    and the its ngrok address will be printed to stdout
    :param app: a Flask application object
    :return: None
    """
    old_run = app.run

    def new_run():
        thread = Timer(1, start_ngrok)
        thread.setDaemon(True)
        thread.start()
        old_run()
    app.run = new_run

"""Sending dash link to Text Message"""

def send_text_msg(body):
  import smtplib
  from email.mime.multipart import MIMEMultipart 
  from email.mime.text import MIMEText

  sender = 'xxx@gmail.com'
  to = 'xxxxxxxxxxx@mms.att.net'
  #to = '8584721623@txt.att.net'
  msg = MIMEMultipart()
  msg['From'] = sender
  msg['To'] = to
  msg['Subject'] = 'Ford Smart SMS Notification'
  #body = 'd97bbbcec0c6.ngrok.io/simulator/StopEngine' 
  message = body
  msg.attach(MIMEText(message))

  mailserver = smtplib.SMTP('smtp.gmail.com',587)
  # identify ourselves to smtp gmail client
  mailserver.ehlo()
  # secure our email with tls encryption
  mailserver.starttls()
  # re-identify ourselves as an encrypted connection
  mailserver.ehlo()
  mailserver.login('xxxx@gmail.com', 'xxxxx')

  mailserver.sendmail(sender,to,msg.as_string())

  mailserver.quit()
  print('Complete sending text message')

send_text_msg('test')

"""**Off peak Electric information**"""

def bestOffPeak():
  import pandas as pd
  import requests
  import re
  from bs4 import BeautifulSoup
  html = 'https://www.sdge.com/residential/pricing-plans/about-our-pricing-plans/whenmatters'
  source = requests.get(html)

  soup = BeautifulSoup(source.text, "html.parser")
  table = soup.find('table')
  print(table)
  table_rows = table.find_all('tr')

  res = []
  time_info = []
  for tr in table_rows:
      td = tr.find_all('td')
      #print(td)
      #print('--')
      #result = re.findall(r'(\d+\s[p|a]\.m)\..*(\d+\s[a|p]\.m)\.',td)
      #print(result)
      row = [tr.text.strip() for tr in td if tr.text.strip()]
      if row:
          res.append(row)

  print(res)
  res_string = "\n".join(res[0])
  print(res_string)
  result = re.findall(r'(\d+\s[p|a]\.m)\..*(\d+\s[a|p]\.m)\.',res_string)
  print(result)
  result_to_midnight = re.findall(r'(\d+\s[p|a]\.m).*midnight',res_string)
  print(result_to_midnight[0] + ' - ' + '12 a.m')
  result_from_midnight = re.findall(r'Midnight.*(\d+\s[p|a]\.m)',res_string)
  print('12 a.m' + ' - ' + result_from_midnight[0])


  print('--------')
  peak_time = {'Super Off-Peak$':[],'Off-Peak$':[], 'On-Peak$':[]}
  if result_to_midnight:
    peak_time['Off-Peak$']=[(result[1][0],result[1][1]),(result_to_midnight[0],'12 a.m')]
  else:
    peak_time['Off-Peak$']=[(result[2][0],result[2][1])]
  if result_from_midnight:
    peak_time['Super Off-Peak$']=[(result[0][0],result[0][1]),('12 a.m', result_from_midnight[0])]
  else:
    peak_time['Super Off-Peak$']=[(result[0][0],result[0][1])]
  peak_time['On-Peak$']=[(result[2][0],result[2][1])]



  print(peak_time)
  #df = pd.DataFrame(res, columns=["Year", "Mintage", "Quality", "Price"])
  #print(df)
 
  TODAY_CHECK = datetime.datetime.now()
  print(TODAY_CHECK)
  today = datetime.date.today()
  print("Today date is: ", str(today))

  length_dict = {key: len(value) for key, value in peak_time.items()}
  length_key = length_dict['Super Off-Peak$']  # length of the list stored at `'key'` ...
  print(f'key length ={length_key}')

  #chek is best time for scheduling
  for i in range(length_key):
    start_time = str(today) + ' ' + peak_time['Super Off-Peak$'][i][0]
    start_time = start_time.replace('.','')
    end_time =   str(today) + ' ' + peak_time['Super Off-Peak$'][i][1]
    end_time = end_time.replace('.','')
    #date_a = DateTime.strptime('10-02-2015 05:05:06 PM', '%d-%m-%Y %I:%M:%S %p')
    print(f'starting time={start_time}')
    print(f'ending time={end_time}')
    
    best_start_time = datetime.datetime.strptime(start_time, '%Y-%m-%d %I %p')
    best_end_time =   datetime.datetime.strptime(end_time, '%Y-%m-%d %I %p')
    print(best_start_time, best_end_time)
    if best_start_time <= TODAY_CHECK <= best_end_time:
        print("It is super off peak : charge your EV for saving $$$")
        return True
    else:
        print("It is not super off peak : not suggest to charge your EV for saving $")
        return False

def getHostIpAddr():
  import socket
  s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  s.connect(("8.8.8.8", 80))
  ip =s.getsockname()[0]
  print(f'ip={ip}')
  s.close()
  return ip

def distanceMeasure(origin,destination):
    
  lat1, lon1 = origin
  lat2, lon2 = destination
  radius = 6371  # km

  dlat = math.radians(lat2 - lat1)
  dlon = math.radians(lon2 - lon1)
  a = (math.sin(dlat / 2) * math.sin(dlat / 2) +
       math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
       math.sin(dlon / 2) * math.sin(dlon / 2))
  c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
  d = radius * c

  return d * 1000 # return with meter

"""**Main Loop**"""

from flask import Flask, render_template
from flask import jsonify
import time
from flask import *
#from flask_ngrok import run_with_ngrok

#from apscheduler.schedulers.background import BackgroundScheduler


app = Flask(__name__, template_folder='./templates')

alarm, home_s, charging, startengine, stopengine = 'OFF', 'OFF', 'OFF', 'OFF','OFF'
op_status =""
log_msg =""
ev_charge_selected = False
stolen_car_selected = False
templateData = {}

@app.route('/')
def home():
  global templateData
  url, vh_info = getVehicleInfo()
  op_status = vh_info['vehicle']['vehicleStatus']['remoteStartStatus']['status']
  templateData = {
              'vehicle_id':vh_info['vehicle']['vehicleId'],
              'model_name':vh_info['vehicle']['modelName'] ,
              'model_year':vh_info['vehicle']['modelYear'],
              'alarm'  : alarm,
              'home'  : home_s,
              'charging'  : charging,
              'startengine'  : startengine,
              'stopengine'  : stopengine,
              'log_msg' : (url,vh_info),
              'op_status': op_status,
              'ngro_address' : str(ngrok_address),
  }
  
  return render_template('simulator.html',**templateData)
@app.route('/dash')
def dash():
  global templateData
  url, vh_info = getVehicleInfo()
  op_status = vh_info['vehicle']['vehicleStatus']['remoteStartStatus']['status']
  templateData = {
              'vehicle_id':vh_info['vehicle']['vehicleId'],
              'model_name':vh_info['vehicle']['modelName'] ,
              'model_year':vh_info['vehicle']['modelYear'],
              'alarm'  : alarm,
              'home'  : home_s,
              'charging'  : charging,
              'startengine'  : startengine,
              'stopengine'  : stopengine,
              'log_msg' : (url,vh_info),
              'op_status': op_status,
              'ngro_address' : str(ngrok_address),
  }
  
  return render_template('dash.html',**templateData)

@app.route('/ev_scheduling')
def ev_scheduling():
  return render_template('ev_schedule.html')

@app.route('/simulator/<action>')
def action(action):   
  global alarm, home_s, charging, startengine, stopengine, op_status, log_msg
  global templateData
  global ev_charge_selected
  global stolen_car_selected 
  alarm, home_s, charging, startengine, stopengine = 'OFF', 'OFF', 'OFF', 'OFF','OFF'
  if action == 'Alarm':
    print(f'Alarm action is selected')
    log_msg = getVehicleStatus()
    op_status = 'Alarming : Tire pressure low'
    log_msg[1]['vehiclestatus']['alarm'] = 'low tire pressure'
    alarm ='ON'
    ev_charge_selected = False
    stolen_car_selected = False
  elif action == 'Stolen':
    print(f'Stolen action is selected')
    log_msg = getVehicleStatus()
    json_result = getLocation()[1]
    park_loc = (float(json_result['vehicleLocation']['latitude']), float(json_result['vehicleLocation']['longitude']))

    current_loc = (42.300290,-83.205193)
    d = distanceMeasure(park_loc, current_loc)
    print(f'{park_loc} {current_loc} distance={d}')
    if d > 2: # moved beyon 2meter
      print("moved more than 2 meters")
    op_status = 'Alarming : Car is stolen'
    log_msg[1]['vehiclestatus']['alarm'] = 'Car is stolen'
    alarm ='ON'
    if stolen_car_selected == False:
      send_text_msg("Ford Smart Card Notification\n Car is stolen" + " " + 
                  f'http://{getHostIpAddr()}:5000/dash')
      stolen_car_selected = True
  elif action == 'HomeArrival':
    print(f'Home Arrival is selected')
    op_status = 'Arriving Home'
    log_msg = getLocation()
    home_s = 'ON'
    ev_charge_selected = False
    stolen_car_selected = False
  elif action == 'EvSchedule':
    print(f'EV Charing is selected')
    charging = 'ON'
    if ev_charge_selected == False:
      if bestOffPeak():
        log_msg = getVehicleStatus()
        op_status = 'Scheduling EV battery'
        """
        send_text_msg("Ford Smart Card Notification\n Best Charging Time" + " " + 
                  str(ngrok_address).replace('http://','') + '/ev_scheduling')
                  """
      else:
        log_msg = getVehicleStatus()
        op_status = 'Not good for Scheduling EV battery'
      ev_charge_selected = True
  elif action == 'StopEngine':
    print(f'Stop Engine is selected')
    stopengine = 'ON'
    log_msg = stopEngine()
    op_status = "Stopping Engine"
    ev_charge_selected = False
    stolen_car_selected = False
  elif action == 'StartEngine':
    print(f'Start Engine is selected')
    startengine = 'ON'
    log_msg = startEngine()
    op_status = "Started Engine"
    ev_charge_selected = False
    stolen_car_selected = False
  
  
    
  templateData['alarm'] = alarm
  templateData['home'] = home_s
  templateData['charging'] = charging
  templateData['startengine'] = startengine
  templateData['stopengine'] = stopengine
  templateData['log_msg'] = log_msg
  templateData['op_status'] = op_status
  templateData['ngro_address'] = str(ngrok_address)
  return render_template('simulator.html', **templateData)

@app.route('/ev_scheduling/show')
def ev_scheduling_show():
  global templateData
  templateData = {
              'op_status': op_status,
	}
  return render_template('ev_schedule.html', **templateData) 

@app.route('/ev_scheduling')
@app.route('/ev_scheduling/<action>')
def ev_scheduling_start(action):
  global op_status
  global templateData
  global alarm, home_s, charging, startengine, stopengine, op_status, log_msg
  if action == 'start':
    op_status = 'EV Charging'
    log_msg = startCharging()
  if action == 'stop':
    op_status = ''
    log_msg = stopCharging()
  templateData['op_status'] = op_status
  templateData['battery_level'] = '35'
  return render_template('ev_schedule.html', **templateData)  

@app.route('/stolen_car')
def stolen_car():
  global op_status
  global templateData
  templateData['op_status'] = op_status
  return render_template('stolen_car.html', **templateData) 

@app.route('/notification')
def update_notification():
    # obtain jsonify from Flask: from flask import jsonify
    # you may change the output/format as you need
    datumpy = datetime.datetime.now()
    datumpy = datumpy.strftime("%Y-%m-%d %H:%M:%S")
    if op_status =="":
      datumpy = datumpy + ' ' + json.dumps('What a beautiful Ford Car!')
    else:
      datumpy = datumpy + ' ' + json.dumps(op_status)
    return jsonify({'value': datumpy})

@app.context_processor
def update_template_data():
  return {'op_status': op_status}

"""
def refresh_simulator():
  templateData = {
              'op_status': op_status,
	}
  return render_template('ev_schedule.html', **templateData)  
"""
  

#daniel_run_with_ngrok(app)
"""
sched = BackgroundScheduler(daemon=True)
sched.add_job(refresh_simulator,'interval',seconds=4)
sched.start()
"""
app.run(host="0.0.0.0")

